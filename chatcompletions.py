from openai import OpenAI
client = OpenAI()
from nltk.corpus import words

english_words = set(words.words()) #using set instead to optimize lookup time


def getWords(bee):
    """Argument: bee, a string of 7 characters representing the 7 letters of today's spelling bee.
       Returns a list of the possible pangrams of those 7 letters
    """
    alphabet = set('abcdefghijklmnopqrstuvwxyz') #set of the english alph
    beeLetters = set(bee)
    remAlph = str(alphabet - beeLetters) #find remaining letters of the english alphabet

    allWords = [] #empty list to eventually store final pangrams in

    for word in english_words: #loop through NLKT provided eng dictionary
        countBeeLetters = 0#count of instances of the bee letters within instance of word
        skipThisWord = False #skip current word if any other letter in remAlph is in it
        for i in range(len(remAlph)):
            if str(remAlph)[i] in word: #if any other letter in word
                skipThisWord = True #skip!
                break
        if skipThisWord == True: #skip the word, move on to next word in english_words
            continue

        for i in range(7):#check if bee letters are in word
            if bee[i] in word:
                countBeeLetters +=1
        if countBeeLetters == 7: #once you reach a count of seven bee letters, you have a pangram, so add current word to the final list
            allWords += [word]
    return ', '.join(allWords)

def getWordsList(bee):
    """Argument: bee, a string of 7 characters representing the 7 letters of today's spelling bee.
       Returns a list of the possible pangrams of those 7 letters
    """
    alphabet = set('abcdefghijklmnopqrstuvwxyz') #set of the english alph
    beeLetters = set(bee)
    remAlph = str(alphabet - beeLetters) #find remaining letters of the english alphabet

    allWords = [] #empty list to eventually store final pangrams in

    for word in english_words: #loop through NLKT provided eng dictionary
        countBeeLetters = 0#count of instances of the bee letters within instance of word
        skipThisWord = False #skip current word if any other letter in remAlph is in it
        for i in range(len(remAlph)):
            if str(remAlph)[i] in word: #if any other letter in word
                skipThisWord = True #skip!
                break
        if skipThisWord == True: #skip the word, move on to next word in english_words
            continue

        for i in range(7):#check if bee letters are in word
            if bee[i] in word:
                countBeeLetters +=1
        if countBeeLetters == 7: #once you reach a count of seven bee letters, you have a pangram, so add current word to the final list
            allWords += [word]
    return allWords



def isCompoundWord(pangram):
    """
    Checks to see if the pangram is a compound word
    Argument: the pangram
    Returns: bool, isCompound 
    """

    for i in range(len(pangram)):#loops through letters in the pangram 
        if (pangram[:i] in english_words) and (pangram[i:] in english_words):#iterates through the pangram, comparing different sections to locate two separate words if they exist
            return True
    return False
    



def letterCount(pangram):
    """
    Argument: pangram, a str representing the pangram of today's bee
    Returns a hashmap of the count of each letter in the pangram
    """
    letter = pangram[0] 
    letterCount = {}
    for letter in pangram:
        if letter in letterCount:
            letterCount[letter] += 1
        else:
            letterCount[letter] = 1
    return str(letterCount)


def firstLetter(pangram):
    """
    Argument: Pangram, a str representing today's bee's pangram
    Returns the first letter of the first pangram in the list of pangrams generated by getWords(bee)
    """
    firstPangram = pangram[0]
    return "The first letter of the pangram is: " + firstPangram[0]



def offerWord(pangramString):
    """Utilizes OpenAI's API to determine the popularity of the pangram
       Argument: pangramString, making a String out of the list of strings pangrams generated from getWords
       Returns message, the string that gpt-3,5-turbo generates
    """
    completion = client.chat.completions.create(
    model="gpt-3.5-turbo", #using gpt-3.5-turpo, not 4o
    messages=[
        {"role": "system", "content": "You are an english expert."}, #prompt engineering 101!
        {"role": "user", "content": "Out of these words, which is the most popular? " + pangramString + "Just respond with the more popular word. Your response should only be one word, and have no special characters in it. it should be all lowercase. "} #pangramString ensured to be a string of pangrams separated by commas
    ]
    )
    message = completion.choices[0].message.content #accesses just the message content, not the role of the chat completion (OpenAI API's documentation)
    return message


def justThePangram(chatCompletion):
    """Argument: chatCompletion, the string generated by offerWord
       Returns int index, the index at which to splice the generated chat message to determine the optimal pangram
    """
    index = 0
    for i in range(len(chatCompletion)):
        if chatCompletion[i] == " ": #I noticed the chat completed with "BlahBlah" is the most popular word. So, I loop through until I hit a space and then splice the string form there
            index = i
            return index


def givePangram(bee): 
    """
    Master function to give the optimal, most popular pangram for today's bee. Uses many helper functions. 
    """
    pangrams = getWords(bee)
    chat = offerWord(pangrams)
    #index = justThePangram(chat)
    #answer = chat[1:index-1]
    return chat

def isCompoundBool(isCompound):
    if isCompound:
        return "YES IT'S A COMPOUND"
    else:
        return "NO COMPOUND"

    

#print(givePangram("rainbow"))
#chat = offerWord(pangramString)
#bool = isCompoundWord(givePangram("rainbow"))
#print(isCompoundBool(bool))

print(givePangram("baptize"))

pangram = givePangram("baptize")
print(isCompoundWord(pangram))

#print(chat[:index])